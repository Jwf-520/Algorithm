## 数组

### `vector`

#### 定义和初始化

```cpp
(1)vector<int> a(10); //定义了10个整型元素的向量（尖括号中为元素类型名，它可以是任何合法的数据类型），但没有给出初值，其值是不确定的。
(2)vector<int> a(10,1); //定义了10个整型元素的向量,且给出每个元素的初值为1
(3)vector<int> a(b); //用b向量来创建a向量，整体复制性赋值
(4)vector<int> a(b.begin(),b.begin+3); //定义了a值为b中第0个到第2个（共3个）元素
(5)int b[7]={1,2,3,4,5,9,8};
vector<int> a(b,b+7); //从数组中获得初值
```

#### 常用的函数

```cpp
(1)a.assign(b.begin(), b.begin() + 3); //b为向量，将b的0~2个元素构成的向量赋给a
(2)a.assign(4, 2); //是a只含4个元素，且每个元素为2
(3)a.back(); //返回a的最后一个元素
(4)a.front(); //返回a的第一个元素
(5)a[i]; //返回a的第i个元素，当且仅当a[i]存在2013-12-07
(6)a.clear(); //清空a中的元素
(7)a.empty(); //判断a是否为空，空则返回ture,不空则返回false
(8)a.pop_back(); //删除a向量的最后一个元素
(9)a.erase(a.begin() + 1, a.begin() + 3); //删除a中第1个（从第0个算起）到第2个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin() + 3（不包括它）
(10)a.push_back(5); //在a的最后一个向量后插入一个元素，其值为5
(11)a.insert(a.begin() + 1, 5); //在a的第1个元素（从第0个算起）的位置插入数值5，如a为1,2,3,4，插入元素后为1,5,2,3,4
(12)a.insert(a.begin() + 1, 3, 5); //在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5
(13)a.insert(a.begin() + 1, b + 3, b + 6); //b为数组，在a的第1个元素（从第0个算起）的位置插入b的第3个元素到第5个元素（不包括b+6），如b为1,2,3,4,5,9,8，插入元素后为1,4,5,9,2,3,4,5,9,8
(14)a.size(); //返回a中元素的个数；
(15)a.capacity(); //返回a在内存中总共可以容纳的元素个数
(16)a.resize(10); //将a的现有元素个数调至10个，多则删，少则补，其值随机
(17)a.resize(10, 2); //将a的现有元素个数调至10个，多则删，少则补，其值为2
(18)a.reserve(100); //将a的容量（capacity）扩充至100，也就是说现在测试a.capacity();的时候返回值是100.这种操作只有在需要给a添加大量数据的时候才显得有意义，因为这将避免内存多次容量扩充操作（当a的容量不足时电脑会自动扩容，当然这必然降低性能） 
```

#### 遍历方式

1. 普通遍历

```cpp
for (int i = 0; i < a.size(); i++) cout << a[i] << ' ';
```

2. 迭代器遍历

```cpp
for (auto i = a.begin(); i != a.end(); i++) cout << *i << ' ';
```

3. 基于for循环的范围遍历

```cpp
for (auto x : a ) cout << x << ' ';
```

#### 重要算法

```cpp
头文件#include<algorithm>
(1)sort(a.begin(), a.end()); //对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列
(2)reverse(a.begin(), a.end()); //对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1
(3)copy(a.begin(), a.end(), b.begin() + 1); //把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开始复制，覆盖掉原有元素
(4)find(a.begin(), a.end(), 10); //在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置
```

#### vector的扩容机制

`STL`中的`vector`是封装了动态数组的顺序容器。不过与动态数组不同的是，`vector`可以根据需要自动扩大容器的大小。具体策略是每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。
在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。

#### resize和reserve的区别

## 链表

### 单链表

链表节点：

```cpp
struct Node {
    int val;
    Node* next;
    Node():val(0), next(nullptr){}
    Node(int val):val(val), next(nullptr){}
}
```

### 双链表`list`

#### 定义和初始化

```cpp
 list<int>lst1;          //创建空list
 list<int> lst2(5);       //创建含有5个元素的list
 list<int>lst3(3,2);  //创建含有3个元素的list
 list<int>lst4(lst2);    //使用lst2初始化lst4
 list<int>lst5(lst2.begin(),lst2.end());  //同lst4
```

#### 常用操作函数

```cpp
Lst1.assign() 给list赋值 
Lst1.back() 返回最后一个元素 
Lst1.begin() 返回指向第一个元素的迭代器 
Lst1.clear() 删除所有元素 
Lst1.empty() 如果list是空的则返回true 
Lst1.end() 返回末尾的迭代器 
Lst1.erase() 删除一个元素 
Lst1.front() 返回第一个元素 
Lst1.insert() 插入一个元素到list中 
Lst1.pop_back() 删除最后一个元素 
Lst1.pop_front() 删除第一个元素 
Lst1.push_back() 在list的末尾添加一个元素 
Lst1.push_front() 在list的头部添加一个元素 
Lst1.rbegin() 返回指向第一个元素的逆向迭代器 
Lst1.rend() 指向list末尾的逆向迭代器 
Lst1.resize() 改变list的大小 
Lst1.reverse() 把list的元素倒转 
Lst1.size() 返回list中的元素个数 
Lst1.sort() 给list排序 
Lst1.unique() 删除list中重复的元素
```

#### 遍历方式

```cpp
 for (list<int>::const_iterator iter = lst1.begin(); iter != lst1.end(); iter++) {
      cout<<*iter;
 }
```

## 字符串

### `string`

#### 定义和初始化

初始化有两种方式，其中使用等号的是拷贝初始化，不使用等号的是直接初始化。

```cpp
string str1 = "hello world";      // str1 = "hello world"
string str2("hello world");       // str2 = "hello world"
string str3 = str1;               // str3 = "hello world"
string str4(str2);                // str4 = "hello world"
string str5(10,'h');              // str5 = "hhhhhhhhhh"
string str6 = string(10,'h');     // str6 = "hhhhhhhhhh"
string str7(str1,6);              // str7 = "world"     从字符串str1第6个字符开始到结束，拷贝到str7中
string str8 = string(str1,6);     // str8 = "world"
string str9(str1,0,5);            // str9 = "hello"     从字符串str1第0个字符开始，拷贝5个字符到str9中
string str10 = string(str1,0,5);  // str10 = "hello"
char c[] = "hello world";
string str11(c,5);                // str11 = "hello"    将字符数组c的前5个字符拷贝到str11中
string str12 = string(c,5);       // str12 = "hello"
```

#### 常用的操作函数

```cpp
(1)str1.size()获取字符串长度
(2)insert函数的使用
string str = "hello world";
string str2 = "hard ";
string str3 = "it is so happy wow";
//s.insert(pos,n,ch)        在字符串s的pos位置上面插入n个字符ch
str.insert(6,4,'z');        // str = "hello zzzzworld"
//s.insert(pos,str)         在字符串s的pos位置插入字符串str
str.insert(6,str2);         // str = "hello hard world"

//s.insert(pos,str,a,n)     在字符串s的pos位置插入字符串str中位置a到后面的n个字符
str.insert(6,str3,6,9);     // str = "hello so happy world"

//s.insert(pos,cstr,n)      在字符串s的pos位置插入字符数组cstr从开始到后面的n个字符
//此处不可将"it is so happy wow"替换为str3
str.insert(6,"it is so happy wow",6);       // str = "hello it is world"
str.insert(str.begin() + 5,','); //在str的第5位的后面插入“,” 
(3)erase函数的使用
string str = "welcome to my blog";
//s.erase(pos, n)           把字符串s从pos开始的n个字符删除
str.erase(11, 3);           // str = "welcome to blog"
(4)substr函数的使用
string str = "The apple thinks apple is delicious";
//s.substr(pos,n)                      得到字符串s位置为pos后面的n个字符组成的串
string s1 = str.substr(4, 5);           // s1 = "apple"
//s.substr(pos)                        得到字符串s从pos到结尾的串
string s2 = str.substr(17);            // s2 = "apple is delicious"
(5)swap函数的使用
string str1 = "small leaf";
string str2 = "big leaf";
//或者str1.swap(str2)  ,输出结果相同
swap(str1,str2);        // str1 = "big leaf"     str2 = "small leaf"
swap(str1[0],str1[1]);  // str1 = "ibg leaf"
(6)数值转换
to_string(val)	      //把val转换成string
stoi(s)	          //把字符串s转换int
stol(s)	          //把字符串s转换成long
(7)find函数的使用
string中find()返回值是字母在母串中的位置（下标记录），如果没有找到，那么会返回一个特别的标记npos，也就是-1。（返回值可以看成是一个int型的数）
string str = "The apple thinks apple is delicious";     //长度34
string key = "apple";
//s.find(str)            查找字符串str在当前字符串s中第一次出现的位置
int pos1 = str.find(key);                  // 4
//s.find(str,pos)        查找字符串str在当前字符串s的[pos,end]中第一次出现的位置
int pos2 = str.find(key, 10);              // 17
//s.find(cstr,pos,n)     查找字符数组cstr前n的字符在当前字符串s的[pos,end]中第一次出现的位置
//此处不可将"delete"替换为str2（如果定义str2 = "delete"）
int pos3 = str.find("delete", 0, 2);       // 26
//s.find(ch,pos)         查找字符ch在当前字符串s的[pos,end]中第一次出现的位置
int pos4 = str.find('s', 0);
```

#### string类的实现

```cpp
#ifndef __MYSTRING__
#define __MYSTRING__

#include <cstring>
#include <iostream>

class String {
public:
	String(const char* cstr = 0);			// 构造函数
	String(const String& str);				// 拷贝构造函数
	String(String&& str);					// 移动构造函数
	String& operator=(const String& str);	// 拷贝赋值函数
	~String();								// 析构函数
	char* get_c_str() const { return m_data; }
private:
	char* m_data;
};

// 构造函数
inline String::String(const char* cstr) {
	if (cstr) {
		m_data = new char[strlen(cstr) + 1];
		strcpy(m_data, cstr);
	} else {
		m_data = new char[1];
		*m_data = '\0';
	}
}
// 拷贝构造函数
inline String::String(const String& str) {
	m_data = new char[strlen(str.m_data) + 1];
	strcpy(m_data, str.m_data);
}
// 移动构造函数
inline String::String(String&& str) : m_data(str.m_data) {
	str.m_data = nullptr;
}
// 拷贝赋值函数
inline String& String::operator=(const String& str) {
	if (this == &str) {
		return *this;
	}
	delete[] m_data;
	m_data = new char[strlen(str.m_data) + 1];
	strcpy(m_data, str.m_data);
	return *this;
}
// 析构函数
inline String::~String() {
	delete[] m_data;//这里一定要delete[]，因为new出来是一个指针数组
}
// 输出操作符重载需设置成非成员函数
std::ostream& operator<<(std::ostream& os, const String& str) {
	os << str.get_c_str();
	return os;
}
#endif
```

### 字符串函数的实现

#### `strcpy`函数的实现

```cpp
char * strcpy(char* strDest, char* strSrc) {
    //断言判空
    assert((str1 != NULL && str2 != NULL));
    //考虑相等，直接返回；
    if (strDest == strStc) return;
    char* address = strDest;
    // 计算字符串长度+‘\0’
    size_t size = strlen(strSrc) + 1;
    // 无内存重叠，正常复制
    if (strDest < strSrc || strDest >= srcSrc + size) {
        while ((*strDest++ = *strSrc++) != '\0');
    } else {
    //有内存重叠高处复制
        char* d = strDest + size - 1;
        char* s = strSrc + size - 1;
        while (size--) {
            *d-- = *s--;
        }
    }
    return address;
}
```

####  `memcpy`函数的实现

```cpp
// 考虑内存重叠
void* Memcpy(void *dst,const void *src,size_t len){
    if(dst == nullptr || src == nullptr)
        return nullptr;
    // reptr保存dst返回值
    void * retpr = dst;
    // 无内存重叠，低地址开始复制 dst < src || src + size <= dst
    if(dst <= src|| ((char*)dst) >= (char*)src+len) {
        while(len--) {
            *(char*)dst = *(char*)src;
            dst = (char*)dst+1;
            src = (char*)src+1;
        }
    } else {
        // 有内存重叠，高地址开始复制
        src = (char*)src+len-1;
        dst = (char*)dst+len-1;
        while(len--) {
            *(char*)dst = *(char*)src;
            dst = (char*)dst-1;
            src = (char*)src-1;
        }
    }
    return retpr;
}
```

> 关于memcpy，要注意。
> 1.参数和返回类型都是void*，不要写char*
> 2.第三个参数别写int，一定要写size_t(size_t在64位是long型 占8字节，而在32字节是unsigned int型 占4位)
> 3.函数体内一定要将void转换为char，因为要保证是按字节copy的。

#### `strcmp`函数的实现

> while遇到'\0'会退出循环
> `str1 == str2` 返回零
> `str1 > str2` 返回正数
> `str1 < str2` 返回负数

```cpp
int strcmp(char* str1, char* str2) {
    assert(str1 != NULL && str2 != NULL);
    while ((*str1) && (*str2) && (*str1 == *str2)) {
        str1++;
        str2++;
    }
    return *str1 - *str2;
}
```

#### `strcat`函数的实现

`c_str()`方法是`const char*`常量指针（即可读不可改变），指向的内容不可以更改。

```cpp
char* strcat(char* str1, char* str2) {
    assert((str1 != NULL && str2 != NULL));
    char* ret = str1;
    while (*str1 != '\0') str1++;
    while ((*str1 = *str2) != '\0') {
        str1++;
        str2++;
    };
    return ret;
}
```

#### `strlen`函数的实现

```cpp
int strlen(char* str1) {
    assert(str1 != NULL);
    int len = 0;
    while (*str1 != '\0') {
        len++;
        str1++;
    }
    return len;
}
```

### `KMP`算法

1. s模式串(长)
2. p模板串(短)
3. `next`存储每一个下标对应的部分匹配值。

`next`数组的含义：对`next[j] `，是`p[1, j]`串中前缀和后缀相同的最大长度（部分匹配值）。

![KMP1](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/KMP1.png)

(1) 求next数组的思路

![KMP2](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/KMP2.png)

```cpp
for(int i = 2, j = 0; i <= m; i++) {
    while(j && p[i] != p[j+1]) j = next[j];
    if(p[i] == p[j+1]) j++;
    next[i] = j;
}
```

> 注意点：i = 2是因为这样当前匹配的话才会有公共前后缀。

(2)匹配字符串

**s串 和 p串都是从1开始的。i 从1开始，j 从0开始，每次s[i] 和p[j + 1]比较**。

![KMP3](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/KMP3.PNG)

`s[a, b] = p[1, j] && s[i] != p[j + 1] `,此时要移动p串(直接移动到下次能匹配的位置)。

1串：`[1, next[j]]`

3串：`[j - next[j] + 1, j]`

1串等于3串，3串等于2串。

所以直接移动p串从1串的位置移动到3串的位置。该操作可由`j = next[j]`直接完成。

如此往复直到`j == m`匹配成功。

```cpp
for(int i = 1, j = 0; i <= n; i++) {
    //如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串
    //用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)
    while(j && s[i] != p[j+1]) j = next[j];//while里的判断条件j是指j退无可退的时候，跳出循环
    if(s[i] == p[j+1]) j++;
    //当前元素匹配，j移向p串下一位
    if(j == m) {
        //匹配成功，进行相关操作
        j = next[j];  //继续匹配下一个子串
    }
}
```

整体代码:

```cpp
#include<iostream>
using namespace std;
const int M = 1000010;
const int N = 100010;
char s[M];
char p[N];
int ne[N];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m;
    cin >> n >> p + 1 >> m >> s + 1;  //小技巧字符串输入从下标1开始输入
    //获取next数组
    for (int i = 2, j = 0; i <= n; i++) {
        while (j && p[i] != p[j + 1]) j = ne[j];
        if (p[i] == p[j + 1]) j++; //为什么这里不用&&j，'&&j'的话就跳过第一次匹配了。
        ne[i] = j;
    }
    //模式匹配
    for (int i = 1, j = 0; i <= m; i++) {
        while (j && s[i] != p[j + 1]) j = ne[j];
        if (s[i] == p[j + 1]) j++;
        if ( j == n) {
            cout << i - n << " ";
            j = ne[j];
        }
    }
    return 0;
}
```

## 树

### 二叉树

#### 遍历方式

1. 先序遍历

  ```cpp
  递归
      
  迭代
  ```

2. 中序遍历

  ```cpp
  递归
      
  迭代
  ```

3. 后序遍历

  ```cpp
  递归
      
  迭代
  ```
4. 层序遍历

#### 二叉树的构造



### 字典树`Trie`

![Trie1](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/Trie1.png)

```cpp
 class Trie {
    public:
        Trie():children(26, nullptr), isWord(false) {}
        void insert(string word) {
            Trie* p = this;
            for (auto c : word) {
                if (p->children[c - 'a'] == nullptr) p->children[c - 'a'] = new Trie();
                p = p->children[c - 'a'];
            }
            count[p]++;
            p->isWord = true;
        }
        bool find(string word) {
            Trie* p = this;
            for (auto c : word) {
                //这一步很关键
                if (p->children[c - 'a'] == nullptr || p->children[c - 'a']->isWord == false) return 0;
                p = p->children[c - 'a'];
            }
            return p->isWord;
        }
    private:
        vector<Trie*> children;
        bool isWord;
        unordered_map<Trie*, int> count;
};
```

##  哈希表

##  堆

## 栈

### 普通栈`stack`

```cpp
#include <iostream>
#include <string>

using namespace std;
const int N = 100010;
int stk[N];
int tt;

//插入
void push(int x) {
    stk[++tt] = x;
}
//弹出
void pop() {
    tt--;
}
//看是否为空
string isEmpty() {
    if (tt > 0) return "NO";
    else return "YES";
} 

//返回栈顶值
int query() {
   return stk[tt]; 
}

int main() {
    int m;
    cin >> m;
    
    while (m--) {
        string s;
        cin >> s;
        if (s == "push") {
            int x;
            cin >> x;
            push(x);
        } else if (s == "query") {
            cout << query() << endl;
        } else if (s == "pop") {
             pop();
        } else if (s == "empty") {
            cout << isEmpty() << endl;
        }
    }
    return 0;
}
```

常用的函数

```cpp
size()
empty()
push()  向栈顶插入一个元素
top()  返回栈顶元素
pop()  弹出栈顶元素
```

### 单调栈

用单调递增栈，当该元素可以入栈的时候，栈顶元素就是它左侧第一个比它小的元素。

用单调递减栈，当前元素可以入栈的时候，栈顶元素就是它右侧第一个比它大的元素。

三步走：

1、维持递增栈或者递减栈

2、将栈顶元素放入final result

3、把当前iterate元素放入栈(可以是实际value，也可以是index)。

```cpp
常见模型：找出每个数左边离它最近的比它大/小的数
单调栈可以维护索引，可以维护数组元素里面的值
stack<int> st;
for (int i = 0; i < n; i++) {
    while(!st.empty() && check(skt.top(), i)) st.pop();
    st.push(i);
}
```

## 队列

### 双端队列`deque`

常用函数：

```cpp
size()
empty()
clear()
front()/back()
push_back()/pop_back()
push_front()/pop_front()
begin()/end()
```

底层原理：

### 队列`queue`

常用函数:

```cpp
size()
empty()
push()  向队尾插入一个元素
front()  返回队头元素
back()  返回队尾元素
pop()  弹出队头元素
```

### 单调队列

含义：所有元素都是单调的，实现是**双端队列**，队列存入的元素为数组索引，队头元素窗口的最大或者最小的元素。

**<font size='5' color='red'>队头删除不符合有效窗口的元素，队尾删除不符合最值的候选元素。</font>**

当窗口滑动后：

+ 如果队头元素滑出了窗口，头尾元素出队。

+ 如果新滑入的元素比队尾保存的索引对应的元素小，则队尾出队。直到新滑入的元素比队尾保存的索引对应的元素大。然后队尾入队。

+ 当窗口全部滑入数组后，开始输出，队头保存的就是窗口内的最小元素，最大值与最小值的处理过程类似。

```cpp
deque<int> q;
for (int i = 0; i < n; i++) {
    while(!q.empty() && check_out(q.front())) q.pop_front(); //维护滑动窗口
    while(!q.empty() && check(q.back(), i) q.pop_back(); //维护队列的单调性
    q.push_back(i); //索引加入栈
    //处理结果
}
```

## 图论

### 拓扑排序

算法流程：
1、从图中选择一个入度为0的顶点，输出该顶点。
2、从图中删除该节点及其所有出边(即与之邻接的所有顶点入度-1)。
3、反复执行这两个步骤，直至所有节点都输出，即整个拓扑排序完成；或者直至剩下的图中再没有入度为零的节点，这就说明了此图中有回路，不可能进行拓扑排序。
模板四步走：
1、建图
2、建入度
3、找入口
4、`BFS`拓扑排序

```cpp
207---课程表
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        unordered_map<int, list<int>> graph;
        vector<int> indegree(numCourses, 0); //根据边建立图，计算入度
        for (int i = 0; i < prerequisites.size(); i++) { //这里是用挂链表的方式保存图邻接表
            int end = prerequisites[i][0], start = prerequisites[i][1];
            graph[start].push_back(end);
            indegree[end]++;    //[0, 1]图的方向是从1指向0，0的入度有所增加，end<-start
        }
        queue<int> que;
        for (int i = 0; i < indegree.size(); i++) { //找到入度为零的顶点，输出顶点
            if (indegree[i] == 0) que.push(i);
        }
        int count = 0; //根据拓扑排序的顺序，进行广度优先搜索
        while (!que.empty()) {
            int cur = que.front();
            que.pop();
            count++;
            for (list<int>::iterator iter = graph[cur].begin(); iter != graph[cur].end(); iter++) {
                //这一步真的很精髓啊。
                //从图中删除该节点及其所有出边(即与之邻接的所有顶点入度-1)。
                //假如有一个出边的度为0，那吗下次就把这个出边节点当作顶点
                if (--indegree[*iter] == 0) que.push(*iter);
            } 
        }
        return count == numCourses; 
    }         
};
210---课程表II
 class Solution {
public:
    //拓扑排序
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
       //1、建图
       //2、建入度
        unordered_map<int, vector<int>> graph;
        vector<int> inDegree(numCourses, 0);
        vector<int> res;
        if (prerequisites.size() == 0) {
            for (int i = 0; i < numCourses; i++) {
                res.push_back(i);
            }
            return res;
        }
        for (int i = 0; i < prerequisites.size(); i++) {
            int end = prerequisites[i][0], start = prerequisites[i][1];
            graph[start].push_back(end);
            inDegree[end]++;
        }
        queue<int> que;
       //3、找入度为零的点
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) que.push(i);
        }
       //4、bfs
       while (!que.empty()) {
           int cur = que.front();
           que.pop();
           res.push_back(cur);
           //找出下一个入度为零的点
           for (auto iter : graph[cur]) {
               if (--inDegree[iter] == 0) que.push(iter);
           }
       }
       if (res.size() == numCourses) return res;
       return {};
    }
};
115 ---重建序列
解题思路：
    1）如果seqs的序列出现了org中不存在的节点（org是1~n的全排列，因此很好判断），直接返回false
	2）如果遇到org中的某个节点没描述依赖关系，返回false
	3）如果遇到入度为0的节点个数大于1（说明不唯一），或者不存在入度0的节点（说明出现环依赖，这一点和课程表一样），返回false
    4）如果重建序列的时候出现序列不匹配，返回false
class Solution {
public:
    bool sequenceReconstruction(vector<int>& org, vector<vector<int>>& seqs) {
        int n = org.size();
        unordered_map<int, vector<int>> graph;
        vector<int> inDegree(n + 1, 0); 
        unordered_set<int> set;
        for (auto& seq : seqs) {
            for (int i = 0; i < seq.size(); i++) {
                set.insert(seq[i]);
                if (seq[i] < 1 || seq[i] > n) return false;  -----1
                if (i == 0) continue;
                graph[seq[i - 1]].push_back(seq[i]);
                inDegree[seq[i]]++;
            } 
        }
        if (n != set.size()) return false;//重建的序列长度与原序列长度不一致
        queue<int> que;
        for (int i = 1; i <= n; i++) {
            if (inDegree[i] == 0) que.push(i); //找到入度为零的点
        }
        int index = 0;
        while (!que.empty()) {
            if (que.size() > 1) return false;  //说明有入度相同的点，那吗重建序列不唯一
            int curNode = que.front();		   
            if (org[index++] != curNode) return false;  //如果重建序列的节点与原序列数值不一样
            que.pop();
            for (auto& num : graph[curNode]) {
                if (--inDegree[num] == 0) que.push(num);
            }
        }
        return index == n;               //重建序列的长度是否等于原序列长度，解决自环问题
    }
};
```

### 并查集
基本原理：每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点。

> 一般使用并查集时需要将二维坐标转换为一维坐标二维坐标转一维坐标：二维坐标`(x, y)`, 可以转换成`x * n + y`(m是棋盘的行数，n是棋盘的列数)。

**关键点:**

1. 将两个集合合并
2. 询问两个元素是否在一个集合当中
```cpp
class DSU {
public:
    //节点x的父节点是parent[x]
    vector<int> parent;
    //记录连通分量
    int count;
    DSU(int n):parent(vector<int>(n)), count(n){
        //父节点指针初始化指向自己
     	for (int i = 0; i < n; i++) {
            parent[i] = i;
        }  
    }
    //判断节点x和节点y是否连通
    bool connected(int x, int y) {
        int rootx = find(x);
        int rooty = find(y);
        return rootx == rooty;
    }
    //寻找树根
    int find(int x) {
        if (parent[x] != x) parent[x] = find(parent[x]); //当x的父节点不是根节点，就要递归寻找父节点的父节点，直到找到根节点。
        return parent[x];    							 //返回根节点，即x所在集合编号
    }
    //将x合并到y上
    void union(int x, int y) {							//将b的祖宗节点作为a的祖宗节点的父节点。
        int rootx = find(x);
        int rooty = find(y);
        if (rootx == rooty) return;
        //将两棵树合并为一棵
		parent[rooty] = rootx; 
        //两个分量合二为一
        count--;
    }
    int count() {
        return count;
    }
};
```

### 图
#### 图的遍历

拿到一个看这个图是有向图还是无向图，是有权重还是无权重，有没有环。

1) 邻接表
```cpp
//graph[x]存储的是所有邻居节点以及对应的权重
unordered_map<int, vector<int>> graph;
/*
图：
0 -- 1
| 	 |
3 -- 2
*/
建图方法：
map<int, list<int>> graph;
graph[0].push_back(1);
graph[0].push_back(3);
graph[1].push_back(2);
graph[1].push_back(0);
graph[2].push_back(3);
graph[2].push_back(1);
graph[3].push_back(0);
graph[3].push_back(3);
```
2. 邻接矩阵
```cpp
// 邻接矩阵
// matrix[x][y] 记录 x 指向 y 的边的权重，0 表示不相邻
vector<vector<int>> matrix;
```
3. 图的遍历框架

> 我们应该把 `onPath` 的操作放到 for 循环外面，否则会漏掉记录起始点的遍历。
> 再说下 `visited` 数组，其目的很明显了，由于图可能含有环，`visited` 数组就是防止递归重复遍历同一个节点进入死循环的。
> **当然，如果题目告诉你图中不含环，可以把 `visited` 数组都省掉，基本就是多叉树的遍历。**

```cpp
// 记录被遍历过的节点
vector<bool> visited;
// 记录从起点到当前节点的路径
vector<bool> onPath;
/* 图遍历框架 */
void traverse(Graph graph, int s) {
    if (visited[s]) return;
    // 经过节点 s，标记为已遍历
    visited[s] = true;
    // 做选择：标记节点 s 在路径上
    onPath[s] = true;
    for (int neighbor : graph[s]) {
        traverse(graph, neighbor);
    }
    // 撤销选择：节点 s 离开路径
    onPath[s] = false;
}
```
#### 有向图的环检测
```cpp
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        unordered_map<int, vector<int>> graph;
        vector<bool> visited(numCourses, false);
        vector<bool> onePath(numCourses, false);
        bool hasCycle = false; //判断是否有环
        for (auto edge : prerequisites) {
            int from = edge[1], to = edge[0];
            graph[from].push_back(to);
        }
        for (int i = 0; i < numCourses; i++) {
            /*注意图中并不是所有节点都相连，所以要用一个for循环将所有节点都作为起点调用一次DFS搜索算法。
            主要是找节点不相连*/
            traversal(graph, i, visited, onePath, hasCycle);
        }
        return !hasCycle;
    }

    void traversal(unordered_map<int, vector<int>>& graph, int s, vector<bool>& visited, vector<bool>& onePath, bool& hasCycle) {
        if (onePath[s]) {
            //发现环了
            hasCycle = true;
        }
        if (visited[s] || hasCycle) {
            return;
        }
        //将s标记为已经遍历过
        visited[s] = true;
        //记录当前遍历走过的路径，开始遍历s
        onePath[s] = true; //path.push_back()
        for (int t : graph[s]) {
            traversal(graph, t, visited, onePath, hasCycle);
        }
        //节点s结束遍历
        onePath[s] = false;//path.pop_back();
        return;
    }
};
```

